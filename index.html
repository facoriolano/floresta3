<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sussurros da Mata Maldita - Edição Expandida</title>
    <style>
        /* --- ESTÉTICA RETRÔ 8-BITS --- */
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --bg-color: #050408;
            --ui-bg: #1a1621;
            --ui-border: #5a5066;
            --text-color: #c7c1ce;
            --highlight: #d46536;
            --verb-active: #ffffff;
            --verb-bg-active: #d46536;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            font-family: 'VT323', monospace;
            color: var(--text-color);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
        }

        /* CANVAS THREE.JS */
        #game-canvas {
            flex-grow: 1;
            image-rendering: pixelated;
            cursor: crosshair;
        }

        /* INTERFACE (UI) */
        #ui-container {
            height: 250px;
            background-color: var(--ui-bg);
            border-top: 4px solid var(--ui-border);
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.8);
        }

        .row { display: flex; gap: 10px; height: 100%; }

        /* PAINEL ESQUERDO: VERBOS */
        #verbs-panel {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-gap: 5px;
            border: 2px solid var(--ui-border);
            padding: 5px;
            background: #110e14;
        }

        .verb-btn {
            background: transparent;
            border: none;
            color: var(--highlight);
            font-family: 'VT323', monospace;
            font-size: 1.3rem;
            cursor: pointer;
            text-align: left;
            text-transform: uppercase;
            padding-left: 10px;
        }

        .verb-btn:hover { color: #fff; }
        .verb-btn.active {
            background-color: var(--verb-bg-active);
            color: var(--verb-active);
        }

        /* PAINEL CENTRAL: LOG DE TEXTO */
        #log-panel {
            flex: 2;
            background: #000;
            border: 2px solid var(--ui-border);
            padding: 10px;
            overflow-y: auto;
            font-size: 1.1rem;
            line-height: 1.3;
            display: flex;
            flex-direction: column-reverse;
        }
        
        .log-entry { margin-bottom: 4px; border-bottom: 1px dashed #222; padding-bottom: 2px; }
        .log-entry.combat { color: #ff5555; }
        .log-entry.heal { color: #55ff55; }
        .log-entry.item { color: #55ffff; }
        .log-entry.narrative { color: #aaa; font-style: italic; }
        .log-entry.puzzle { color: #d46536; font-weight: bold; }

        /* PAINEL DIREITO: INVENTÁRIO E STATUS */
        #side-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #stats-box {
            border: 2px solid var(--ui-border);
            padding: 5px;
            font-size: 1.2rem;
            background: #110e14;
            color: #fff;
        }

        #inventory-grid {
            flex-grow: 1;
            border: 2px solid var(--ui-border);
            background: #110e14;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
            grid-gap: 2px;
            padding: 2px;
            align-content: start;
        }

        .inv-slot {
            width: 100%;
            height: 100%;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.8rem;
            color: #888;
            position: relative;
        }
        
        .inv-slot:hover { border-color: var(--highlight); color: #fff; }
        .inv-count { position: absolute; bottom: 0; right: 2px; color: #fff; font-size: 0.7rem;}

        /* TOOLTIP */
        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid var(--highlight);
            color: #fff;
            padding: 4px 8px;
            font-size: 1rem;
            pointer-events: none;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 10px rgba(212, 101, 54, 0.5);
        }

        /* OVERLAY */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 4, 8, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            text-align: center;
        }
        
        h1 { font-size: 4rem; color: var(--highlight); margin: 0; text-shadow: 4px 4px 0 #000; line-height: 0.9; }
        .btn-start {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 2rem;
            font-family: 'VT323', monospace;
            background: var(--highlight);
            border: 4px solid #fff;
            cursor: pointer;
            color: #fff;
            transition: all 0.2s;
        }
        .btn-start:hover { transform: scale(1.05); background: #fff; color: #000; }

    </style>
    <!-- IMPORTANDO THREE.JS VIA CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <!-- MENSAGEM INICIAL / GAME OVER -->
    <div id="overlay">
        <h1>SUSSURROS DA<br>MATA MALDITA</h1>
        <p style="font-size: 1.5rem; color: #888; margin-top: 10px;">Edição Expandida: Puzzles, Masmorras & Combate</p>
        <button class="btn-start" onclick="startGame()">ENTRAR NA FLORESTA</button>
        <p style="font-size: 1rem; margin-top:20px; color: #555;">DICA: Use 'ATACAR' para lutar um turno.<br>Use 'USAR' + Clique na Poção para curar.</p>
    </div>

    <!-- TOOLTIP DINÂMICO -->
    <div id="tooltip"></div>

    <!-- CANVAS DO JOGO -->
    <div id="game-canvas"></div>

    <!-- INTERFACE -->
    <div id="ui-container">
        <div class="row">
            <!-- Verbos -->
            <div id="verbs-panel">
                <button class="verb-btn active" data-verb="ANDAR">ANDAR</button>
                <button class="verb-btn" data-verb="OLHAR">OLHAR</button>
                <button class="verb-btn" data-verb="PEGAR">PEGAR</button>
                <button class="verb-btn" data-verb="USAR">USAR</button>
                <button class="verb-btn" data-verb="FALAR">FALAR</button>
                <button class="verb-btn" data-verb="ABRIR">ABRIR</button>
                <button class="verb-btn" data-verb="ATACAR">ATACAR</button>
                <button class="verb-btn" data-verb="EMPURRAR">EMPURRAR</button>
            </div>

            <!-- Log -->
            <div id="log-panel">
                <div class="log-entry narrative">Você está na orla da floresta antiga...</div>
            </div>

            <!-- Stats & Inv -->
            <div id="side-panel">
                <div id="stats-box">
                    VIGOR: <span id="hp-val" style="color:#5f5">20</span>/20<br>
                    SORTE: <span id="luck-val" style="color:#ee5">10</span>
                </div>
                <div id="inventory-grid">
                    <!-- Slots gerados via JS -->
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * SUSSURROS DA MATA MALDITA - V2.0
 * Arquivo Único - Three.js + Canvas API + Web Audio API
 */

// --- 1. SISTEMA DE ÁUDIO AVANÇADO (Ambiente + SFX) ---
const AudioSys = {
    ctx: null,
    masterGain: null,
    ambienceNode: null,
    ambienceGain: null,
    
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.5;
        this.masterGain.connect(this.ctx.destination);

        this.ambienceGain = this.ctx.createGain();
        this.ambienceGain.connect(this.masterGain);
    },

    // Gera ruído rosa para vento/caverna
    createNoiseBuffer: function() {
        const bufferSize = 2 * this.ctx.sampleRate;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const output = buffer.getChannelData(0);
        let b0, b1, b2, b3, b4, b5, b6;
        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
        for (let i = 0; i < bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            output[i] *= 0.11; 
            b6 = white * 0.115926;
        }
        return buffer;
    },

    playAmbience: function(type) {
        if (!this.ctx) return;
        if (this.ambienceNode) {
            this.ambienceNode.stop();
            this.ambienceNode = null;
        }

        const buffer = this.createNoiseBuffer();
        const src = this.ctx.createBufferSource();
        src.buffer = buffer;
        src.loop = true;

        // Filtro para mudar o "tom" do ambiente
        const filter = this.ctx.createBiquadFilter();
        if (type === 'forest') {
            filter.type = 'lowpass';
            filter.frequency.value = 400; // Vento abafado
            this.ambienceGain.gain.value = 0.3;
        } else if (type === 'cave') {
            filter.type = 'highpass';
            filter.frequency.value = 100; // Ecos
            this.ambienceGain.gain.value = 0.6;
        } else {
            this.ambienceGain.gain.value = 0; // Sem som
        }

        src.connect(filter);
        filter.connect(this.ambienceGain);
        src.start();
        this.ambienceNode = src;
    },

    playTone: function(freq, type, duration, vol=0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },

    sfx: {
        step: (terrain) => {
            const f = terrain === 'stone' ? 200 : 100;
            AudioSys.playTone(f, 'triangle', 0.05, 0.1);
        },
        click: () => AudioSys.playTone(800, 'square', 0.03, 0.05),
        error: () => AudioSys.playTone(150, 'sawtooth', 0.3, 0.2),
        item: () => {
            AudioSys.playTone(1200, 'sine', 0.1, 0.1); 
            setTimeout(()=>AudioSys.playTone(1800, 'sine', 0.3, 0.1), 100);
        },
        potion: () => { // Som de beber
            AudioSys.playTone(400, 'sine', 0.1, 0.2);
            setTimeout(()=>AudioSys.playTone(600, 'sine', 0.2, 0.2), 100);
        },
        puzzle: () => { // Som de runa
            AudioSys.playTone(220, 'sine', 0.5, 0.2);
        },
        puzzleSolve: () => {
            [523, 659, 783, 1046].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'triangle', 0.4, 0.2), i*200));
        },
        hit: () => AudioSys.playTone(60, 'sawtooth', 0.1, 0.3),
        attack: () => AudioSys.playTone(300, 'square', 0.1, 0.1),
        win: () => {
            [440, 554, 659, 880].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'square', 0.3, 0.2), i*150));
        }
    }
};

// --- 2. GERADOR DE ASSETS GRÁFICOS (Pixel Art Procedural) ---
const Art = {
    cache: {},
    pal: {
        blk: '#050408', blu: '#1d2b53', pur: '#7e2553', grn: '#008751',
        brn: '#ab5236', gry: '#5f574f', wht: '#fff1e8', red: '#ff004d',
        org: '#ffa300', yel: '#ffec27', stone: '#757161', drk: '#222034'
    },
    createTexture: function(name, width, height, palette, pixels) {
        if (this.cache[name]) return this.cache[name];
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const code = pixels[y * width + x];
                if (code !== 0) { 
                    ctx.fillStyle = palette[code];
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.magFilter = THREE.NearestFilter;
        texture.minFilter = THREE.NearestFilter;
        this.cache[name] = texture;
        return texture;
    },
    generateAssets: function() {
        const P = this.pal;
        // 1. Texturas de Terreno
        this.createTexture('grass', 4, 4, {1:P.grn, 2:P.blk}, [1,2,1,1, 1,1,1,2, 2,1,1,1, 1,1,2,1]);
        this.createTexture('floor_stone', 4, 4, {1:P.gry, 2:P.stone}, [1,1,2,1, 1,2,2,1, 2,1,1,1, 1,1,1,2]);
        this.createTexture('wall', 4, 4, {1:P.drk, 2:P.gry}, [1,2,1,2, 2,1,2,1, 1,2,1,2, 2,1,2,1]);

        // 2. Sprites (8x8 ou 16x16)
        const npc = [0,0,1,1,1,0,0,0, 0,0,1,3,1,0,0,0, 0,2,2,2,2,2,0,0, 0,0,2,2,2,0,0,0, 0,0,2,0,2,0,0,0, 0,0,1,0,1,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0];
        this.createTexture('npc', 8, 8, {1:P.wht, 2:P.blu, 3:P.red}, npc);

        const skull = [0,0,1,1,1,0,0,0, 0,1,1,1,1,1,0,0, 1,1,2,1,2,1,1,0, 1,1,1,1,1,1,1,0, 0,1,2,1,2,1,0,0, 0,0,1,2,1,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0];
        this.createTexture('skull', 8, 8, {1:P.wht, 2:P.blk}, skull);

        const spider = [1,0,0,0,0,0,0,1, 0,1,0,0,0,0,1,0, 0,0,1,2,2,1,0,0, 0,0,2,3,3,2,0,0, 0,0,2,3,3,2,0,0, 0,0,1,2,2,1,0,0, 0,1,0,0,0,0,1,0, 1,0,0,0,0,0,0,1];
        this.createTexture('spider', 8, 8, {1:P.blk, 2:P.drk, 3:P.red}, spider);

        const potion = [0,0,0,1,0,0,0,0, 0,0,1,2,1,0,0,0, 0,0,1,3,1,0,0,0, 0,1,3,3,3,1,0,0, 0,1,3,3,3,1,0,0, 0,1,3,3,3,1,0,0, 0,0,1,1,1,0,0,0, 0,0,0,0,0,0,0,0];
        this.createTexture('potion', 8, 8, {1:P.wht, 2:P.gry, 3:P.red}, potion);

        const rune = [0,1,1,1,1,1,1,0, 1,2,2,2,2,2,2,1, 1,2,3,2,2,3,2,1, 1,2,2,3,3,2,2,1, 1,2,2,3,3,2,2,1, 1,2,3,2,2,3,2,1, 1,2,2,2,2,2,2,1, 0,1,1,1,1,1,1,0];
        this.createTexture('rune_active', 8, 8, {1:P.stone, 2:P.gry, 3:P.cyn}, rune);
        this.createTexture('rune_inactive', 8, 8, {1:P.stone, 2:P.gry, 3:P.blk}, rune);

        // Árvore
        this.createTexture('tree', 16, 16, {1:P.grn, 2:P.brn, 3:P.blk},
            [0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0, 0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0, 0,1,1,1,3,1,1,1,1,1,0,0,0,0,0,0, 0,1,1,1,1,1,3,1,1,1,0,0,0,0,0,0,
             0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0, 0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0, 0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0, 0,0,0,0,2,3,2,0,0,0,0,0,0,0,0,0,
             0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0, 0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0].concat(new Array(16*6).fill(0)));
             
        // Porta
        this.createTexture('door', 16, 16, {1:P.gry, 2:P.blk, 3:P.org},
            new Array(256).fill(1).map((v,i) => (i%16===0 || i%16===15 || i<16) ? 1 : (i>200 && i<220 && i%16>6 && i%16<10) ? 3 : 2));
    }
};

// --- 3. LÓGICA DO JOGO ---
const Game = {
    state: {
        currentVerb: 'ANDAR',
        inventory: ['Poção'], // Começa com uma para teste
        flags: { puzzle: [] }, 
        stats: { hp: 20, maxHp: 20, luck: 10 },
        location: 'start'
    },
    
    log: function(text, type='normal') {
        const logPanel = document.getElementById('log-panel');
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.innerText = `> ${text}`;
        logPanel.prepend(entry);
    },

    // --- LÓGICA DE AÇÃO ---
    handleAction: function(objId, objData) {
        const verb = this.state.currentVerb;
        const flags = this.state.flags;

        // 1. Movimento (Mudança de Cena)
        if (verb === 'ANDAR') {
            if (objData.type === 'exit') {
                this.loadScene(objData.target);
                AudioSys.sfx.step(objData.terrain || 'grass');
                return;
            } else {
                this.log("Não posso ir para lá.", "narrative");
                AudioSys.sfx.error();
                return;
            }
        }

        // 2. Interações Específicas
        if (objData.type === 'enemy') {
            if (verb === 'ATACAR') {
                this.combatRound(objData);
            } else if (verb === 'OLHAR') {
                this.log(`Inimigo: ${objData.name}. HP: ${objData.hp}`, "combat");
            } else {
                this.log("Melhor não irritar mais...", "narrative");
            }
            return;
        }

        // 3. Puzzles e Objetos
        switch(objId) {
            case 'rune_1': case 'rune_2': case 'rune_3':
                if (verb === 'USAR' || verb === 'EMPURRAR') {
                    this.handlePuzzle(objId, objData);
                } else if (verb === 'OLHAR') this.log("Uma runa mágica gravada no chão.");
                break;
            
            case 'chest':
                if (verb === 'ABRIR') {
                    if (flags.chestOpen) this.log("Vazio.");
                    else {
                        flags.chestOpen = true;
                        this.log("Encontrou: Poção e Mapa!");
                        this.addToInventory('Poção');
                        this.addToInventory('Poção'); // Dá duas
                        AudioSys.sfx.item();
                    }
                }
                break;

            case 'gate':
                if (verb === 'ABRIR') {
                    if (flags.puzzleSolved) {
                        this.log("O portão secreto das ruínas se abre!");
                        flags.ruinGateOpen = true;
                        AudioSys.sfx.win();
                        this.loadScene('secret_room');
                    } else {
                        this.log("Trancado magicamente. As runas devem ser a chave.", "narrative");
                    }
                }
                break;

            case 'key_item':
                if (verb === 'PEGAR') {
                    this.addToInventory('Chave');
                    flags.hasKey = true;
                    Scene.removeObject(objId);
                    this.log("Pegou a Chave Antiga.");
                    AudioSys.sfx.item();
                }
                break;

            case 'forest_gate':
                if(verb === 'ABRIR') {
                    if(flags.hasKey) {
                        this.log("A chave abre o portão da floresta!");
                        this.loadScene('deep_forest');
                        AudioSys.sfx.win();
                    } else this.log("Trancado. Precisa de uma chave.");
                }
                break;

            default:
                if (verb === 'OLHAR') this.log(`Você vê: ${objData.name}`);
                else if (verb === 'FALAR' && objData.type === 'npc') this.log(`${objData.name}: "Cuidado com as aranhas na caverna..."`);
                else {
                    this.log("Nada acontece.");
                    AudioSys.sfx.error();
                }
        }
    },

    // --- PUZZLE DAS RUNAS ---
    handlePuzzle: function(id, data) {
        const correctOrder = ['rune_1', 'rune_3', 'rune_2']; // Esquerda, Direita, Meio
        const current = this.state.flags.puzzle;
        
        // Se já clicou nesta, reseta
        if(current.includes(id)) {
            this.log("A runa apaga. A sequência quebrou.", "combat");
            this.state.flags.puzzle = [];
            Scene.updateVisuals(); // Reseta cores
            AudioSys.sfx.error();
            return;
        }

        current.push(id);
        this.log("A runa brilha intensamente...", "puzzle");
        AudioSys.sfx.puzzle();
        
        // Muda visual temporariamente
        Scene.getObject(id).material.map = Art.cache['rune_active'];

        // Verifica ordem
        if (current.length === correctOrder.length) {
            if (JSON.stringify(current) === JSON.stringify(correctOrder)) {
                this.log("A terra treme! O selo foi quebrado.", "heal");
                this.state.flags.puzzleSolved = true;
                AudioSys.sfx.puzzleSolve();
            } else {
                this.log("Um choque percorre o chão! Sequência errada.", "combat");
                this.state.flags.puzzle = [];
                setTimeout(() => Scene.updateVisuals(), 500); // Apaga após um tempo
                AudioSys.sfx.error();
                this.takeDamage(2);
            }
        }
    },

    // --- COMBATE POR TURNOS ---
    combatRound: function(enemy) {
        AudioSys.sfx.attack();
        
        // Player Ataca
        const dmg = Math.floor(Math.random() * 4) + 2; // 2-5 dmg
        enemy.hp -= dmg;
        this.log(`Você ataca ${enemy.name} causando ${dmg} de dano!`, "item");

        // Checa Vitória
        if (enemy.hp <= 0) {
            this.log(`${enemy.name} morreu!`, "heal");
            AudioSys.sfx.win();
            Scene.removeObject(enemy.id);
            
            if (enemy.id === 'boss') {
                this.log("VOCÊ DESTRUIU O MAL DA FLORESTA!", "puzzle");
                setTimeout(() => alert("VITÓRIA! OBRIGADO POR JOGAR."), 1000);
            }
            return;
        }

        // Inimigo Ataca (Resposta)
        setTimeout(() => {
            const enemyDmg = Math.floor(Math.random() * 3) + 1; // 1-3 dmg
            this.takeDamage(enemyDmg);
            this.log(`${enemy.name} contra-ataca! -${enemyDmg} HP`, "combat");
        }, 500);
    },

    takeDamage: function(amount) {
        this.state.stats.hp -= amount;
        AudioSys.sfx.hit();
        this.updateUI();
        if (this.state.stats.hp <= 0) {
            this.log("VOCÊ CAIU EM COMBATE...", "combat");
            document.getElementById('overlay').style.display = 'flex';
            document.querySelector('h1').innerText = "GAME OVER";
        }
    },

    // --- INVENTÁRIO E ITENS ---
    addToInventory: function(item) {
        this.state.inventory.push(item);
        this.updateUI();
    },

    useItem: function(index) {
        const item = this.state.inventory[index];
        
        if (this.state.currentVerb !== 'USAR') {
            this.log(`Selecione 'USAR' para consumir ${item}.`, "narrative");
            return;
        }

        if (item === 'Poção') {
            const heal = 10;
            this.state.stats.hp = Math.min(this.state.stats.hp + heal, this.state.stats.maxHp);
            this.log(`Você bebe a poção. +${heal} HP.`, "heal");
            AudioSys.sfx.potion();
            this.state.inventory.splice(index, 1); // Remove 1 item
            this.updateUI();
        } else {
            this.log(`Não sei como usar ${item} aqui.`);
        }
    },

    updateUI: function() {
        document.getElementById('hp-val').innerText = this.state.stats.hp;
        const grid = document.getElementById('inventory-grid');
        grid.innerHTML = '';
        this.state.inventory.forEach((item, idx) => {
            const div = document.createElement('div');
            div.className = 'inv-slot';
            // Nome abreviado
            div.innerText = item.substring(0,3).toUpperCase();
            
            // Contador se tiver múltiplos (simplificado, mostra todos soltos)
            div.onclick = () => this.useItem(idx);
            grid.appendChild(div);
        });
    },

    loadScene: function(key) {
        this.state.location = key;
        Scene.build(key);
        
        // Audio Ambiente
        const ambience = Scene.data[key].ambience || 'forest';
        AudioSys.playAmbience(ambience);

        this.log(`--- ${Scene.data[key].name} ---`, "narrative");
        this.log(Scene.data[key].desc);
    }
};

// --- 4. CENA (THREE.JS) ---
const Scene = {
    scene: null, camera: null, renderer: null,
    raycaster: new THREE.Raycaster(), mouse: new THREE.Vector2(),
    objects: [],

    data: {
        'start': {
            name: 'Vila Sombria',
            desc: 'O vento uiva. Há uma Caverna ao leste e a Trilha ao norte.',
            ambience: 'forest',
            terrain: 'grass',
            map: [
                { id: 'npc1', type: 'npc', pos: [-2,0,-2], sprite: 'npc', name: 'Aldeão' },
                { id: 'to_forest', type: 'exit', target: 'forest_path', pos: [0,0,-6], sprite: 'door', name: 'Trilha' },
                { id: 'to_cave', type: 'exit', target: 'cave_entrance', pos: [6,0,0], sprite: 'door', name: 'Caverna' }
            ]
        },
        'cave_entrance': {
            name: 'Entrada da Caverna',
            desc: 'Úmida e escura. Teias de aranha cobrem as pedras.',
            ambience: 'cave',
            terrain: 'stone',
            map: [
                { id: 'spider1', type: 'enemy', pos: [3,0,-3], sprite: 'spider', name: 'Aranha Gigante', hp: 10 },
                { id: 'chest', type: 'prop', pos: [5,0,-5], sprite: 'potion', name: 'Baú do Aventureiro' }, // Sprite reuse
                { id: 'back_vila', type: 'exit', target: 'start', pos: [-6,0,6], sprite: 'door', name: 'Sair' }
            ],
            walls: true
        },
        'forest_path': {
            name: 'Trilha Antiga',
            desc: 'Uma bifurcação. Ruínas à esquerda, Mata Fechada à frente (Trancada).',
            ambience: 'forest',
            map: [
                { id: 'to_start', type: 'exit', target: 'start', pos: [0,0,6], sprite: 'door', name: 'Voltar' },
                { id: 'to_ruins', type: 'exit', target: 'ruins_hall', pos: [-6,0,0], sprite: 'door', name: 'Ruínas' },
                { id: 'forest_gate', type: 'prop', pos: [0,0,-6], sprite: 'door', name: 'Portão da Mata' }
            ],
            trees: 10
        },
        'ruins_hall': {
            name: 'Salão das Runas',
            desc: 'Três runas no chão: Esquerda(1), Centro(2), Direita(3). Descubra a ordem.',
            ambience: 'cave',
            terrain: 'stone',
            map: [
                { id: 'rune_1', type: 'prop', pos: [-4,0,0], sprite: 'rune_inactive', name: 'Runa 1' },
                { id: 'rune_2', type: 'prop', pos: [0,0,-2], sprite: 'rune_inactive', name: 'Runa 2' },
                { id: 'rune_3', type: 'prop', pos: [4,0,0], sprite: 'rune_inactive', name: 'Runa 3' },
                { id: 'gate', type: 'prop', pos: [0,0,-6], sprite: 'door', name: 'Portão Selado' },
                { id: 'back_path', type: 'exit', target: 'forest_path', pos: [0,0,6], sprite: 'door', name: 'Sair' }
            ],
            walls: true
        },
        'secret_room': {
            name: 'Câmara Secreta',
            desc: 'Um local esquecido. A chave brilha no altar.',
            ambience: 'cave',
            terrain: 'stone',
            map: [
                { id: 'key_item', type: 'prop', pos: [0,0,0], sprite: 'potion', name: 'Chave Mágica' }, // Reuse sprite
                { id: 'back_hall', type: 'exit', target: 'ruins_hall', pos: [0,0,6], sprite: 'door', name: 'Voltar' }
            ],
            walls: true
        },
        'deep_forest': {
            name: 'Coração da Corrupção',
            desc: 'O Guardião te espera.',
            ambience: 'forest',
            map: [
                { id: 'boss', type: 'enemy', pos: [0,0,-2], sprite: 'skull', name: 'Guardião', hp: 30 }
            ],
            trees: 20
        }
    },

    init: function() {
        const c = document.getElementById('game-canvas');
        const w = c.clientWidth, h = c.clientHeight;
        const aspect = w/h; const d = 12;
        
        this.camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 1000);
        this.camera.position.set(20, 20, 20);
        this.camera.lookAt(0,0,0);

        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x050408);
        
        this.renderer = new THREE.WebGLRenderer({ antialias: false });
        this.renderer.setSize(w, h);
        this.renderer.setPixelRatio(1);
        c.appendChild(this.renderer.domElement);

        c.addEventListener('mousemove', this.onMove.bind(this));
        c.addEventListener('mousedown', this.onClick.bind(this));
        
        this.animate();
    },

    build: function(key) {
        while(this.scene.children.length) this.scene.remove(this.scene.children[0]);
        this.objects = [];
        const data = this.data[key];
        
        const plane = new THREE.PlaneGeometry(1,1);
        const matFloor = new THREE.MeshBasicMaterial({ map: Art.cache[data.terrain === 'stone' ? 'floor_stone' : 'grass'] });
        
        // Chão
        for(let x=-10; x<=10; x+=2) {
            for(let z=-10; z<=10; z+=2) {
                const m = new THREE.Mesh(plane, matFloor);
                m.position.set(x, -1, z);
                m.rotation.x = -Math.PI/2;
                m.scale.set(2,2,1);
                this.scene.add(m);
            }
        }

        // Paredes (Se for interior)
        if (data.walls) {
            const matWall = new THREE.MeshBasicMaterial({ map: Art.cache['wall'] });
            for(let i=-10; i<=10; i+=2) {
                // Parede Norte e Sul
                this.addWall(i, -10, matWall); 
                // Leste Oeste (menos aberturas)
                if(Math.abs(i) > 2) { this.addWall(-10, i, matWall); this.addWall(10, i, matWall); }
            }
        }

        // Árvores
        if (data.trees) {
             const matTree = new THREE.MeshBasicMaterial({ map: Art.cache['tree'], transparent:true, alphaTest:0.5 });
             for(let i=0; i<data.trees; i++) {
                 const m = new THREE.Mesh(plane, matTree);
                 m.position.set((Math.random()*16)-8, 0.5, (Math.random()*16)-8);
                 m.scale.set(3,3,1);
                 m.rotation.x = -Math.PI/4;
                 this.scene.add(m);
             }
        }

        // Objetos
        data.map.forEach(o => {
            if(o.id === 'key_item' && Game.state.flags.hasKey) return;
            if(o.hp && o.hp <= 0) return; // Inimigo morto não renderiza

            const mat = new THREE.MeshBasicMaterial({ map: Art.cache[o.sprite], transparent:true, alphaTest:0.5 });
            const m = new THREE.Mesh(plane, mat);
            m.position.set(o.pos[0], 0, o.pos[2]);
            m.scale.set(2,2,1);
            m.rotation.x = -Math.PI/4;
            
            // Propriedades de jogo no objeto 3D
            m.userData = { ...o }; 
            
            this.scene.add(m);
            this.objects.push(m);
        });
    },

    addWall: function(x, z, mat) {
        const m = new THREE.Mesh(new THREE.PlaneGeometry(1,1), mat);
        m.position.set(x, 0.5, z);
        m.scale.set(2,3,1);
        m.rotation.x = -Math.PI/4; // Isométrico
        this.scene.add(m);
    },

    getObject: function(id) { return this.objects.find(o => o.userData.id === id); },

    updateVisuals: function() {
        // Reseta runas se falhar
        ['rune_1', 'rune_2', 'rune_3'].forEach(id => {
            const obj = this.getObject(id);
            if(obj) obj.material.map = Art.cache['rune_inactive'];
        });
    },

    onMove: function(e) {
        const r = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((e.clientX - r.left)/r.width)*2 -1;
        this.mouse.y = -((e.clientY - r.top)/r.height)*2 +1;
        
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const ints = this.raycaster.intersectObjects(this.objects);
        const tt = document.getElementById('tooltip');
        
        if(ints.length > 0) {
            document.body.style.cursor = 'pointer';
            const obj = ints[0].object;
            obj.material.color.setHex(0xffaaaa);
            tt.style.display = 'block';
            tt.style.left = (e.clientX+15)+'px';
            tt.style.top = (e.clientY+15)+'px';
            tt.innerText = `${Game.state.currentVerb} ${obj.userData.name}`;
        } else {
            document.body.style.cursor = 'crosshair';
            this.objects.forEach(o => o.material.color.setHex(0xffffff));
            tt.style.display = 'none';
        }
    },

    onClick: function() {
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const ints = this.raycaster.intersectObjects(this.objects);
        if(ints.length > 0) {
            const obj = ints[0].object;
            Game.handleAction(obj.userData.id, obj.userData);
        } else {
            // Andar no chão (Feedback visual apenas)
             if(Game.state.currentVerb === 'ANDAR') AudioSys.sfx.step(Scene.data[Game.state.location].terrain);
        }
    }
    ,
    animate: function() {
        requestAnimationFrame(this.animate.bind(this));
        // Bobbing effect
        const t = Date.now()*0.003;
        this.objects.forEach((o,i) => {
            if(o.userData.type === 'enemy' || o.userData.type === 'item') 
                o.position.y = Math.sin(t+i)*0.1; 
        });
        this.renderer.render(this.scene, this.camera);
    }
};

function startGame() {
    document.getElementById('overlay').style.display = 'none';
    AudioSys.init();
    Art.generateAssets();
    Scene.init();
    Game.loadScene('start');
    Game.updateUI();

    document.querySelectorAll('.verb-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            document.querySelectorAll('.verb-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            Game.state.currentVerb = e.target.getAttribute('data-verb');
            AudioSys.sfx.click();
        });
    });
}

</script>
</body>
</html>
